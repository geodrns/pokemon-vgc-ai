import math
import random
import logging
import os
from itertools import combinations

from numpy.random import multinomial
from vgc2.battle_engine.modifiers import Nature
from vgc2.battle_engine.pokemon import PokemonSpecies
from vgc2.competition import Competitor
from vgc2.agent import BattlePolicy, SelectionPolicy, TeamBuildPolicy
from vgc2.agent.battle import RandomBattlePolicy
from vgc2.agent.selection import RandomSelectionPolicy

# — Configuración de logging —
os.makedirs("logs", exist_ok=True)
logging.basicConfig(
    filename="../logs/competitor_mcts_improved.log",
    level=logging.DEBUG,
    format="%(asctime)s %(levelname)s: %(message)s"
)

# — Política de team build basada en MCTS mejorado —
class MCTSTeamBuildPolicy(TeamBuildPolicy):
    def __init__(self, mcts_iterations=100):
        self.mcts_iterations = mcts_iterations
        # Último equipo elegido (lista de índices)
        self.last_team: list[int] | None = None

    class MCTSNode:
        def __init__(self, move=None, parent=None):
            self.move = move            # Tupla de índices (equipo candidato)
            self.parent = parent
            self.children: list[MCTSTeamBuildPolicy.MCTSNode] = []
            self.visits = 0
            self.wins = 0

        def uct_score(self, total_simulations, c=1.414):
            if self.visits == 0:
                return float("inf")
            exploitation = self.wins / self.visits
            exploration = c * math.sqrt(math.log(total_simulations) / self.visits)
            return exploitation + exploration

    class MCTSState:
        def __init__(self, roster: list[PokemonSpecies], max_team_size: int):
            self.roster = roster
            self.max_team_size = max_team_size

        def get_possible_actions(self) -> list[tuple[int, ...]]:
            # Todas las combinaciones posibles de índices de tamaño max_team_size
            return list(combinations(range(len(self.roster)), self.max_team_size))

    def choose_team(self, roster: list[PokemonSpecies], current_team, log, max_team_size: int) -> list[int]:
        """
        Método central de MCTS: construye el árbol, ejecuta simulaciones y elige el mejor equipo.
        """
        # 1) Construir el nodo raíz (sin movimiento asignado)
        root = self.MCTSNode()

        # 2) Generar todas las acciones posibles (equipos candidatos)
        possible_actions = self.MCTSState(roster, max_team_size).get_possible_actions()
        for action in possible_actions:
            child = self.MCTSNode(move=action, parent=root)
            root.children.append(child)

        # 3) Ejecutar iteraciones de MCTS
        for _ in range(self.mcts_iterations):
            # --- Selección: elegir hijo con mayor UCT ---
            total_visits = root.visits + 1  # evitar log(0)
            node = max(root.children, key=lambda n: n.uct_score(total_visits))

            # --- Simulación: rollout heurístico contra equipo aleatorio ---
            reward = self.simulate_rollout(node.move, roster, max_team_size)

            # --- Backpropagation: actualizar estadísticas ---
            node.visits += 1
            node.wins += reward
            root.visits += 1

        # 4) Elegir el movimiento (equipo) con mayor win-rate
        best_child = max(
            root.children,
            key=lambda n: (n.wins / n.visits) if n.visits > 0 else 0
        )
        return list(best_child.move)

    def simulate_rollout(self, team_indices: tuple[int, ...], roster: list[PokemonSpecies], max_team_size: int) -> int:
        """
        Simulación somera: enfrenta el “team_indices” a un equipo rival aleatorio
        utilizando un heurístico basado en la suma de estadísticas base.
        Devuelve 1 si el equipo A (team_indices) vence según el heurístico, 0 en caso contrario.
        """
        # 1) Construir el equipo rival aleatorio (evitar duplicar exactamente el mismo equipo)
        all_indices = set(range(len(roster)))
        pool = list(all_indices - set(team_indices))
        if len(pool) < max_team_size:
            # En caso muy raro de que el roster sea muy pequeño,
            # permiten duplicar índices (causa mínima influencia)
            opponent = random.sample(range(len(roster)), max_team_size)
        else:
            opponent = random.sample(pool, max_team_size)

        # 2) Calcular “score” de cada equipo como sumatorio de stats base (HP + Ataque + Defensa + ...)
        def team_score(indices: list[int]) -> float:
            total = 0.0
            for idx in indices:
                sp = roster[idx]
                # Suma de sus seis estadísticas base
                total += sum(sp.base_stats)
            return total

        score_A = team_score(team_indices)
        score_B = team_score(opponent)

        # 3) Heurístico simple: gana quien tenga mayor puntuación
        return 1 if score_A >= score_B else 0

    def decision(
        self,
        roster: list[PokemonSpecies],
        meta,
        max_team_size: int,
        max_pkm_moves: int,
        n_active: int
    ) -> list[tuple[int, tuple[int, ...], tuple[int, ...], Nature]]:
        """
        1) Ejecuta MCTS puro para elegir índices del equipo.
        2) Construye el TeamBuildCommand con IVs, EVs, naturaleza y movimientos genéricos.
        """
        logging.info("Iniciando MCTS con %d iteraciones", self.mcts_iterations)

        # 1) Obtener lista de índices mediante MCTS
        indices = self.choose_team(roster, None, "", max_team_size)
        logging.info("Índices elegidos por MCTS mejorado: %s", indices)

        # 2) Construcción del TeamBuildCommand esperado por VGC AI
        ivs = (31,) * 6
        cmds = []
        for idx in indices:
            sp = roster[idx]
            mv = list(range(len(sp.moves)))[:max_pkm_moves]
            ev = tuple(multinomial(510, [1 / 6] * 6, size=1)[0])
            nat = Nature(random.randrange(len(Nature)))
            cmds.append((idx, ev, ivs, nat, mv))
            logging.debug("Comando generado para idx %d: %s", idx, cmds[-1])

        logging.info("TeamBuildCommand final: %s", cmds)
        # 3) Devolver la lista de comandos para la competición
        return cmds


class MCTSCompetitor(Competitor):
    def __init__(self, name: str = "MCTSCompetitor"):
        self.__name = name
        self.__battle_policy: BattlePolicy = RandomBattlePolicy()
        self.__selection_policy: SelectionPolicy = RandomSelectionPolicy()
        # Se utiliza la política de team build mejorada
        self.__team_build_policy: TeamBuildPolicy = MCTSTeamBuildPolicy(mcts_iterations=100)

    @property
    def battle_policy(self) -> BattlePolicy | None:
        return self.__battle_policy

    @property
    def selection_policy(self) -> SelectionPolicy | None:
        return self.__selection_policy

    @property
    def team_build_policy(self) -> TeamBuildPolicy | None:
        return self.__team_build_policy

    @property
    def name(self) -> str:
        return self.__name


# — Bloque de prueba para verificar la política de team build —
if __name__ == "__main__":
    from vgc2.util.generator import gen_move_set, gen_pkm_roster

    # Generar un roster de prueba
    move_set = gen_move_set(100)
    roster = gen_pkm_roster(50, move_set)
    max_team_size = 3
    max_pkm_moves = 4

    competitor = MCTSCompetitor("AgenteMCTS_Improved")
    cmds = competitor.team_build_policy.decision(
        roster, None, max_team_size, max_pkm_moves, n_active=max_team_size
    )
    print("Nuevo equipo seleccionado (comando):", cmds)
